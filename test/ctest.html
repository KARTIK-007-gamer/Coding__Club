<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Basic Web & MS Word Test — 30 Questions</title>
  <style>
    :root{--accent:#2563eb;--danger:#dc2626;--bg:#f8fafc;--card:#ffffff}
    *{box-sizing:border-box}
    body{font-family:Inter, system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial; margin:0; background:var(--bg); color:#0f172a}
    header{display:flex;align-items:center;justify-content:space-between;padding:1rem;gap:1rem}
    .brand{display:flex;align-items:center;gap:.6rem}
    .brand h1{font-size:1.05rem;margin:0}
    .timer{font-weight:700;padding:.5rem .75rem;border-radius:8px;background:rgba(37,99,235,0.08)}
    .warning{background:rgba(220,38,38,0.08)}
    main{max-width:980px;margin:0 auto;padding:1rem}
    .controls{display:flex;gap:.5rem;align-items:center}
    .progressbar{height:10px;background:#e6eefc;border-radius:999px;overflow:hidden;width:220px}
    .progressbar > i{display:block;height:100%;width:0%;background:linear-gradient(90deg,var(--accent), #60a5fa)}
    .question-card{background:var(--card);padding:1rem;border-radius:12px;box-shadow:0 6px 18px rgba(11,15,30,0.06);margin-bottom:1rem}
    fieldset{border:0;padding:0;margin:0}
    legend{font-weight:600;margin-bottom:.5rem}
    .options{display:flex;flex-direction:column;gap:.5rem}
    label.option{display:flex;align-items:center;gap:.6rem;padding:.5rem;border-radius:8px;border:1px solid transparent}
    input[type=radio]{margin-right:.5rem}
    label.option:hover{background:#f1f5f9}
    .fixed-submit{position:fixed;right:16px;bottom:16px;display:flex;gap:.5rem;align-items:center}
    button{background:var(--accent);color:white;border:0;padding:.6rem .9rem;border-radius:10px;font-weight:700;cursor:pointer}
    button.secondary{background:transparent;color:var(--accent);border:2px solid rgba(37,99,235,0.12)}
    .results{padding:1rem;background:#fff;border-radius:12px;box-shadow:0 6px 18px rgba(11,15,30,0.06);margin-top:1rem}
    .small{font-size:.9rem;color:#475569}
    .muted{color:#6b7280}
    .correct{color:green;font-weight:700}
    .incorrect{color:var(--danger);font-weight:700}

    /* Modal */
    .modal-backdrop{position:fixed;inset:0;background:rgba(2,6,23,0.6);display:none;align-items:center;justify-content:center;padding:1rem}
    .modal{background:#fff;border-radius:12px;padding:1.25rem;max-width:420px;width:100%;box-shadow:0 10px 30px rgba(2,6,23,0.4);text-align:center}
    .modal h3{margin:0 0 .5rem 0}
    .modal .small{margin-bottom:1rem}
    .modal .actions{display:flex;gap:.5rem;justify-content:center}
    .btn-ghost{background:transparent;color:var(--accent);border:2px solid rgba(37,99,235,0.12)}

    @media (max-width:640px){.controls{flex-direction:column;align-items:flex-start}.progressbar{width:100%}}
  </style>
</head>
<body>
  <header>
    <div class="brand">
      <svg width="36" height="36" viewBox="0 0 24 24" fill="none" aria-hidden><rect width="24" height="24" rx="6" fill="#eef2ff"/><path d="M7 14.5L11 9l4 5.5" stroke="#3730a3" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg>
      <div>
        <h1>Basic Web & MS Word Test</h1>
        <div class="muted small">30 Qs — 30 minutes — 1 mark each</div>
      </div>
    </div>

    <div class="controls">
      <div class="progressbar" title="progress"><i id="progressFill"></i></div>
      <div id="progressText" class="small">Question 0 of 30</div>
      <div id="timer" class="timer" role="timer" aria-live="polite">30:00</div>
    </div>
  </header>

  <main>
    <form id="testForm" aria-label="Basic Web and Word Test">
      <div id="questionsContainer"></div>
    </form>

    <div id="postArea"></div>
  </main>

  <div class="fixed-submit">
    <button id="resetBtn" class="secondary">Reset Test</button>
    <button id="scoreBtn" title="Check Score">Check Score</button>
  </div>

  <!-- Modal shown after scoring -->
  <div id="scoreModal" class="modal-backdrop" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
    <div class="modal">
      <h3 id="modalTitle">Your Score</h3>
      <div id="modalBody" class="small muted">Calculating...</div>
      <div class="actions" style="margin-top:12px">
        <button id="goHomeBtn" class="btn-ghost">Go to Home</button>
        <button id="viewDetailsBtn">View Details</button>
      </div>
    </div>
  </div>

  <script>
  /*
   Updated behavior:
   - "Check Score" button replaces Submit
   - When clicked, shows a centered modal popup with score and two buttons:
     - "Go to Home" (navigates immediately to index.html)
     - "View Details" (closes modal and shows per-question breakdown on the page)
  */

  (function(){
    'use strict';

    const STORAGE_KEY = 'basic_test_v1';
    const DURATION_SECONDS = 30 * 60; // 30 minutes

    // Questions: replaced with 30 C programming questions only
    const QUESTIONS = [
      {id:1, topic:'C', text:'Which function is used to print formatted output to stdout in C?', options:['echo()','cout','printf()','print()'], correctIndex:2, explanation:'printf from stdio.h is used for formatted output in C.'},
      {id:2, topic:'C', text:'Which header must be included to use printf and scanf?', options:['stdlib.h','stdio.h','string.h','math.h'], correctIndex:1, explanation:'stdio.h declares printf and scanf.'},
      {id:3, topic:'C', text:'Which of these is the correct way to declare a character variable?', options:['char c;','character c;','char[] c;','String c;'], correctIndex:0, explanation:'char c; declares a single character variable.'},
      {id:4, topic:'C', text:'What is the correct syntax to declare a function named add that takes two ints and returns an int?', options:['int add(int a, int b);','add(int a, int b) int;','int add(a,b) int a,b;','void add(int a,int b);'], correctIndex:0, explanation:'int add(int a, int b); is a standard prototype for a function returning int.'},
      {id:5, topic:'C', text:'Which symbol starts a single-line comment in C?', options:['/*','//','<!--','##'], correctIndex:1, explanation:'// starts a single-line comment (since C99 commonly used, and compilers accept it).' },
      {id:6, topic:'C', text:'What does the operator * do when placed before a pointer variable in an expression?', options:['Creates pointer','Dereferences pointer to access value','Gets address of variable','Declares a pointer type only'], correctIndex:1, explanation:'*p dereferences p to access the value at the address.'},
      {id:7, topic:'C', text:'Which of the following is correct to allocate dynamic memory for 10 ints?', options:['malloc(10)','malloc(10*sizeof(int))','new int[10]','alloc(10)'], correctIndex:1, explanation:'malloc(10 * sizeof(int)) allocates space for 10 ints in C.'},
      {id:8, topic:'C', text:'Which function frees memory allocated by malloc?', options:['dispose()','delete()','free()','release()'], correctIndex:2, explanation:'free() releases memory allocated by malloc/calloc/realloc.'},
      {id:9, topic:'C', text:'Which format specifier prints an integer in printf?', options:['%d','%f','%c','%s'], correctIndex:0, explanation:'%d (or %i) is used for ints in printf.'},
      {id:10, topic:'C', text:'Which declaration creates an array of 5 integers?', options:['int arr[] = 5;','int arr[5];','int arr{5};','array<int> arr(5);'], correctIndex:1, explanation:'int arr[5]; declares an array of five ints.'},
      {id:11, topic:'C', text:'What is the output of: printf("%d", (int)\'A\'); ? (Assume ASCII)', options:['65','97','1','0'], correctIndex:0, explanation:'\'A\' has ASCII code 65.'},
      {id:12, topic:'C', text:'Which keyword makes a variable constant (read-only) after initialization?', options:['static','const','volatile','immutable'], correctIndex:1, explanation:'const makes a variable read-only; attempting to modify causes a compiler error.'},
      {id:13, topic:'C', text:'Which of these is the correct way to declare a pointer to int?', options:['int *p;','int p*;','ptr int p;','int &p;'], correctIndex:0, explanation:'int *p; declares p as a pointer to int.'},
      {id:14, topic:'C', text:'Which function compares two strings in C?', options:['strcmp()','strcomp()','compare()','strncmp()'], correctIndex:0, explanation:'strcmp from string.h compares C strings; strncmp compares up to n characters.'},
      {id:15, topic:'C', text:'What does sizeof operator return?', options:['Size in bits','Size in bytes','Number of elements','Variable type'], correctIndex:1, explanation:'sizeof returns the size in bytes of a type or expression.'},
      {id:16, topic:'C', text:'Which is the correct way to declare a structure?', options:['struct S {int x;};','structure S {int x;};','struct S = {int x;};','S struct {int x;};'], correctIndex:0, explanation:'struct S { int x; }; defines a struct type named S.'},
      {id:17, topic:'C', text:'Which keyword is used to allocate memory for a new variable with static lifetime inside a function?', options:['auto','register','static','extern'], correctIndex:2, explanation:'static gives a local variable static storage duration (persistent across calls).' },
      {id:18, topic:'C', text:'Which header provides malloc and free declarations?', options:['alloc.h','stddef.h','stdlib.h','memory.h'], correctIndex:2, explanation:'stdlib.h declares malloc, calloc, realloc and free.'},
      {id:19, topic:'C', text:'Which operator gives the address of a variable?', options:['*','&','@','%'], correctIndex:1, explanation:'&x gives the memory address of x.'},
      {id:20, topic:'C', text:'Which function reads a line from input safely (stops at newline or buffer limit)?', options:['gets()','scanf("%s")','fgets()','gets_s()'], correctIndex:2, explanation:'fgets reads a line into a buffer and avoids overflow when used correctly.'},
      {id:21, topic:'C', text:'What is the effect of the statement: int a = 5 / 2; ?', options:['a is 2','a is 2.5','compile error','a is 3'], correctIndex:0, explanation:'Integer division yields 2; fractional part is discarded.'},
      {id:22, topic:'C', text:'Which of the following will correctly declare a function pointer to a function returning int and taking int argument?', options:['int (*fptr)(int);','int fptr*(int);','int *fptr(int);','int fptr(int)*;'], correctIndex:0, explanation:'int (*fptr)(int); declares a pointer to function taking int and returning int.'},
      {id:23, topic:'C', text:'Which preprocessor directive is used to prevent multiple inclusions of a header?', options:['#include','#pragma once or include guards','#define only','#ifdef only'], correctIndex:1, explanation:'Use #ifndef/#define/#endif include guards or #pragma once to prevent double inclusion.'},
      {id:24, topic:'C', text:'Which of the following is true about enum in C?', options:['enum defines a new integer type with named constants','enum is identical to struct','enum stores strings','enum variables are floats'], correctIndex:0, explanation:'enum creates named integer constants; variables have integral type.'},
      {id:25, topic:'C', text:'Which statement about pointers and arrays is correct?', options:['Array name gives address of first element','Pointer arithmetic is unrelated to element size','Arrays can be assigned directly','Array and pointer are identical types'], correctIndex:0, explanation:'An array name (in many contexts) decays to pointer to its first element.'},
      {id:26, topic:'C', text:'What happens if you free memory and then later use the pointer to access it?', options:['Guaranteed correct behavior','Undefined behavior (likely crash)','It will reallocate automatically','Compiler error'], correctIndex:1, explanation:'Using a freed pointer leads to undefined behavior; program may crash or behave unpredictably.'},
      {id:27, topic:'C', text:'Which format specifier should be used to print a pointer value in printf?', options:['%d','%p','%x','%s'], correctIndex:1, explanation:'%p is the standard specifier to print pointer addresses.'},
      {id:28, topic:'C', text:'Which of these will correctly copy a string src to dest (C-style)?', options:['strcpy(dest, src);','dest = src;','copy(dest, src);','strncpy(dest);'], correctIndex:0, explanation:'strcpy(dest, src) copies a C-string; strncpy can be used safely with length limit.'},
      {id:29, topic:'C', text:'Which is true about function parameters in C?', options:['Arrays are passed by value as whole array copy','Pointers allow modification of caller memory','All parameters are passed by reference','C supports pass-by-reference directly'], correctIndex:1, explanation:'Passing a pointer lets the function modify caller memory; arrays decay to pointers.'},
      {id:30, topic:'C', text:'Which of the following is a likely cause of a segmentation fault?', options:['Accessing memory beyond allocated array bounds','Using printf incorrectly','Declaring too many variables','Using const variables'], correctIndex:0, explanation:'Accessing invalid memory addresses (out-of-bounds) commonly causes segmentation faults.'}
    ];

    // Utilities
    function shuffle(arr){
      const a = arr.slice();
      for(let i = a.length - 1; i > 0; i--){
        const j = Math.floor(Math.random() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }

    // Elements
    const container = document.getElementById('questionsContainer');
    const progressText = document.getElementById('progressText');
    const progressFill = document.getElementById('progressFill');
    const timerEl = document.getElementById('timer');
    const scoreBtn = document.getElementById('scoreBtn');
    const resetBtn = document.getElementById('resetBtn');
    const postArea = document.getElementById('postArea');
    const scoreModal = document.getElementById('scoreModal');
    const modalBody = document.getElementById('modalBody');
    const goHomeBtn = document.getElementById('goHomeBtn');
    const viewDetailsBtn = document.getElementById('viewDetailsBtn');

    let shuffledOptionsMap = {}; // questionId -> array of {text,isCorrect}
    let remainingSeconds = DURATION_SECONDS;
    let timerInterval = null;
    let autosaveInterval = null;
    let submitted = false;

    // Render helpers
    function createOptionElements(q){
      const qDef = QUESTIONS.find(x => x.id === q.id);
      const baseOptions = qDef.options.map((t, idx) => ({ text: t, isCorrect: idx === qDef.correctIndex }));
      const shuffled = shuffle(baseOptions);
      shuffledOptionsMap[q.id] = shuffled;

      const optDiv = document.createElement('div');
      optDiv.className = 'options';

      shuffled.forEach((opt, i) => {
        const inputId = `q${q.id}_opt${i}`;
        const input = document.createElement('input');
        input.type = 'radio';
        input.name = `q_${q.id}`;
        input.id = inputId;
        input.value = opt.text; // store displayed text for robust restore
        input.setAttribute('aria-label', opt.text);

        const label = document.createElement('label');
        label.className = 'option';
        label.htmlFor = inputId;
        label.tabIndex = 0;

        const span = document.createElement('span');
        span.textContent = opt.text;

        label.appendChild(input);
        label.appendChild(span);
        optDiv.appendChild(label);
      });

      return optDiv;
    }

    function renderAll(){
      container.innerHTML = '';
      QUESTIONS.forEach((q, idx) => {
        const card = document.createElement('section');
        card.className = 'question-card';
        card.id = `card_${q.id}`;

        const field = document.createElement('fieldset');
        const legend = document.createElement('legend');
        legend.textContent = `${idx + 1}. (${q.topic}) ${q.text}`;
        field.appendChild(legend);

        field.appendChild(createOptionElements(q));
        card.appendChild(field);
        container.appendChild(card);
      });

      updateProgress();
    }

    function updateProgress(){
      const total = QUESTIONS.length;
      let answered = 0;
      QUESTIONS.forEach(q => {
        const sel = document.querySelector(`input[name="q_${q.id}"]:checked`);
        if(sel) answered++;
      });
      progressText.textContent = `Answered ${answered} of ${total}`;
      const pct = Math.round((answered / total) * 100);
      progressFill.style.width = pct + '%';
    }

    function collectAnswers(){
      const answers = {};
      QUESTIONS.forEach(q => {
        const sel = document.querySelector(`input[name="q_${q.id}"]:checked`);
        if(sel) answers[q.id] = sel.value;
      });
      return answers;
    }

    function calculateScore(userAnswers){
      let score = 0;
      const perQ = [];
      QUESTIONS.forEach(q => {
        const shuffled = shuffledOptionsMap[q.id] || [];
        const selectedText = userAnswers[q.id] !== undefined ? userAnswers[q.id] : null;
        const selectedOpt = selectedText ? shuffled.find(o => o.text === selectedText) : null;
        const correctOpt = shuffled.find(o => o.isCorrect);
        const isCorrect = selectedOpt ? selectedOpt.isCorrect : false;
        if(isCorrect) score++;
        perQ.push({ id: q.id, question: q.text, topic: q.topic, selected: selectedOpt ? selectedOpt.text : null, correct: correctOpt ? correctOpt.text : null, explanation: q.explanation, isCorrect });
      });
      return { score, perQ };
    }

    function disableInputs(){
      document.querySelectorAll('input[type="radio"]').forEach(i => i.disabled = true);
    }

    function escapeHtml(str){
      if(!str) return '';
      return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#039;');
    }

    function renderDetails(result){
      postArea.innerHTML = '';
      const box = document.createElement('div');
      box.className = 'results';
      const scorePct = Math.round((result.score / QUESTIONS.length) * 100);
      box.innerHTML = `<h2>Your score: ${result.score} / ${QUESTIONS.length} — ${scorePct}%</h2><div class='small muted'>Time: ${formatTime(remainingSeconds)} remaining when submitted</div><hr>`;

      result.perQ.forEach((q, i) => {
        const qdiv = document.createElement('div');
        qdiv.style.marginBottom = '0.8rem';
        qdiv.innerHTML = `<strong>${i+1}. (${escapeHtml(q.topic)})</strong> <div class='small'>${escapeHtml(q.question)}</div>
          <div class='small'>Your answer: <span class='${q.isCorrect? 'correct':'incorrect'}'>${escapeHtml(q.selected || '— (no answer)')}</span></div>
          <div class='small'>Correct answer: <span class='correct'>${escapeHtml(q.correct || '—')}</span></div>
          <div class='small muted'>Explanation: ${escapeHtml(q.explanation)}</div>`;
        box.appendChild(qdiv);
      });

      postArea.appendChild(box);
    }

    // Persistence
    function saveProgress(state){
      try{ localStorage.setItem(STORAGE_KEY, JSON.stringify(state)); }catch(e){ /* ignore storage errors */ }
    }
    function loadProgress(){
      try{ const raw = localStorage.getItem(STORAGE_KEY); return raw ? JSON.parse(raw) : null; } catch(e){ return null; }
    }

    // Timer + autosave
    function formatTime(s){ const mm = String(Math.floor(s/60)).padStart(2,'0'); const ss = String(s%60).padStart(2,'0'); return `${mm}:${ss}`; }

    function startTimer(){
      clearInterval(timerInterval);
      timerInterval = setInterval(()=>{
        if(submitted) return clearInterval(timerInterval);
        remainingSeconds--;
        timerEl.textContent = formatTime(remainingSeconds);
        if(remainingSeconds <= 120) timerEl.classList.add('warning');
        if(remainingSeconds <= 0){
          timerEl.textContent = '00:00';
          autoSubmitOnExpire();
        }
      }, 1000);
    }

    function autoSubmitOnExpire(){
      if(submitted) return;
      submitted = true;
      const answers = collectAnswers();
      const result = calculateScore(answers);
      disableInputs();
      saveProgress({ submitted: true, remainingSeconds: 0, answers });
      clearInterval(timerInterval);
      clearInterval(autosaveInterval);
      showScoreModal(result);
    }

    function startAutosave(){
      autosaveInterval = setInterval(()=>{
        if(submitted) return;
        const answers = collectAnswers();
        saveProgress({ submitted: false, remainingSeconds, answers });
      }, 10000);
    }

    // Modal
    function showScoreModal(result){
      modalBody.textContent = `You scored ${result.score} out of ${QUESTIONS.length} (${Math.round(result.score / QUESTIONS.length * 100)}%).`;
      scoreModal.style.display = 'flex';
      // one-time handlers
      goHomeBtn.onclick = () => {
        // Preserve current answers and remaining time but mark not-submitted so the user can resume later
        try {
          const cur = loadProgress() || {};
          cur.submitted = false;
          cur.remainingSeconds = remainingSeconds;
          cur.answers = collectAnswers();
          saveProgress(cur);
        } catch (e) {
          // ignore storage errors
        }
        window.location.href = '../tests.html';  // Changed from 'tests.html' to '../tests.html'
      };
      viewDetailsBtn.onclick = ()=>{ scoreModal.style.display = 'none'; renderDetails(result); };
    }

    // Score button
    scoreBtn.addEventListener('click', ()=>{
      if(submitted) return;
      if(!confirm('Check your score now?')) return;
      submitted = true;
      const answers = collectAnswers();
      const result = calculateScore(answers);
      disableInputs();
      saveProgress({ submitted: true, remainingSeconds, answers });
      clearInterval(timerInterval);
      clearInterval(autosaveInterval);
      showScoreModal(result);
    });

    resetBtn.addEventListener('click', ()=>{
      if(!confirm('Reset will clear saved progress and allow a fresh attempt. Proceed?')) return;
      try{ 
        localStorage.removeItem(STORAGE_KEY); 
        // Clear existing intervals
        clearInterval(timerInterval);
        clearInterval(autosaveInterval);
        // Reset timer variables
        remainingSeconds = DURATION_SECONDS;
        submitted = false;
        // Update timer display
        timerEl.textContent = formatTime(remainingSeconds);
        timerEl.classList.remove('warning');
        // Reset UI
        renderAll();
        // Restart timer and autosave
        startTimer();
        startAutosave();
      } catch(e){}
    });

    // Restore
    function restoreIfAny(){
      const state = loadProgress();
      if(!state) return false;
      renderAll();
      if(state.answers){
        Object.keys(state.answers).forEach(qidStr => {
          const qid = parseInt(qidStr, 10);
          const selectedText = state.answers[qid];
          if(!selectedText) return;
          const input = Array.from(document.querySelectorAll(`input[name=\"q_${qid}\"]`)).find(el => el.value === selectedText);
          if(input) input.checked = true;
        });
      }
      if(state.submitted){
        remainingSeconds = state.remainingSeconds || 0;
        submitted = true;
        const answers = state.answers || {};
        const result = calculateScore(answers);
        disableInputs();
        showScoreModal(result);
        return true;
      } else {
        if(state.remainingSeconds) remainingSeconds = state.remainingSeconds;
        return false;
      }
    }

    document.addEventListener('change', (e)=>{ if(e.target && e.target.name && e.target.name.startsWith('q_')) updateProgress(); });

    // keyboard activation for label elements
    document.addEventListener('keydown', (e)=>{
      if(document.activeElement && document.activeElement.classList && document.activeElement.classList.contains('option')){
        if(e.key === 'Enter' || e.key === ' '){
          const input = document.getElementById(document.activeElement.htmlFor);
          if(input && !input.disabled){ input.checked = true; updateProgress(); }
          e.preventDefault();
        }
      }
    });

    // Boot
    (function boot(){
      const hadSubmitted = restoreIfAny();
      if(!hadSubmitted){
        if(container.children.length === 0) renderAll();
        timerEl.textContent = formatTime(remainingSeconds);
        startTimer();
        startAutosave();
      }
    })();

    // Before unload save
    window.addEventListener('beforeunload', ()=>{
      if(submitted) return;
      const answers = collectAnswers();
      saveProgress({ submitted: false, remainingSeconds, answers });
    });

  })();
  </script>
</body>
</html>
